<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Git Diff Tool (Single Page)</title>
    <style>
        :root {
            --bg: #1e1e1e;
            --panel-bg: #252526;
            --border: #3e3e42;
            --text: #d4d4d4;
            --accent: #0e639c;
            --accent-hover: #1177bb;
            --gutter-bg: #1e1e1e;
            --gutter-text: #858585;
            --diff-add-bg: #2ea04333;
            --diff-del-bg: #f8514933;
            --diff-hdr-text: #569cd6;
            --font: Consolas, 'Courier New', monospace;
            --line-height: 20px;
            --font-size: 13px;
        }

        * { box-sizing: border-box; }
        
        body {
            margin: 0; padding: 0;
            background: var(--bg); color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            padding: 8px 15px;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border);
            display: flex; gap: 20px; align-items: center;
            font-size: 13px; user-select: none; 
            flex-shrink: 0; flex-wrap: wrap;
        }
        
        .control-group { display: flex; align-items: center; gap: 12px; border-right: 1px solid #444; padding-right: 20px; }
        .control-group:last-child { border-right: none; }

        label { display: flex; align-items: center; gap: 6px; cursor: pointer; white-space: nowrap; }
        input[type="checkbox"] { cursor: pointer; }
        input[type="number"], input[type="range"] {
            background: #3c3c3c; border: 1px solid #555; color: white;
            padding: 2px 5px; border-radius: 3px; font-family: inherit; font-size: 12px;
        }
        input[type="number"] { width: 60px; text-align: center; }

        /* --- Main Layout --- */
        .main-grid {
            flex: 1; display: flex; flex-direction: row;
            overflow: hidden; min-height: 0; 
        }

        .pane {
            flex: 1; display: flex; flex-direction: column;
            border-right: 1px solid var(--border);
            min-width: 0; min-height: 0;
        }
        .pane:last-child { border-right: none; }

        .pane-title {
            background: #333; color: #ccc;
            padding: 4px 10px; font-size: 11px; font-weight: bold;
            text-transform: uppercase; letter-spacing: 0.5px;
            flex-shrink: 0;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* Editor Area */
        .editor-wrapper {
            flex: 1; display: flex; position: relative; overflow: hidden; min-height: 0;
        }

        .gutter {
            width: 45px; background: var(--gutter-bg); color: var(--gutter-text);
            text-align: right; padding: 10px 5px;
            font-family: var(--font); font-size: var(--font-size); line-height: var(--line-height);
            user-select: none; border-right: 1px solid var(--border);
            overflow: hidden; flex-shrink: 0;
            cursor: default;
        }
        
        /* Common style for Textarea, Output, Mirror */
        .editor-content {
            font-family: var(--font); font-size: var(--font-size); line-height: var(--line-height);
            padding: 10px; tab-size: 4;
            border: none; margin: 0;
        }

        textarea.editor-content, div.editor-content.view-mode {
            flex: 1; background: var(--bg); color: var(--text);
            resize: none; outline: none; white-space: pre; overflow: auto;
        }
        
        /* Mirror ensures exact height calc for word wrap */
        .mirror {
            position: absolute; top: 0; left: 0; visibility: hidden; pointer-events: none;
            width: 100%; height: auto; white-space: pre; overflow: hidden;
            word-break: break-all; 
            padding: 10px; /* Must match editor-content padding */
            font-family: var(--font); font-size: var(--font-size); line-height: var(--line-height);
        }

        /* Word Wrap Toggle Classes */
        .wrap-on textarea, .wrap-on .view-mode, .wrap-on .mirror {
            white-space: pre-wrap; word-break: break-all;
        }

        /* --- Controls Area --- */
        .controls {
            padding: 10px; background: var(--panel-bg);
            border-top: 1px solid var(--border);
            display: flex; gap: 10px; justify-content: center; flex-shrink: 0;
            flex-wrap: wrap;
        }
        
        button {
            background: var(--accent); color: white; border: none;
            padding: 6px 14px; border-radius: 2px; cursor: pointer;
            font-size: 12px; font-weight: bold; font-family: inherit;
        }
        button:hover { background: var(--accent-hover); }
        button:active { transform: translateY(1px); }
        button.secondary { background: #444; }
        button.secondary:hover { background: #555; }
        button.icon-btn { padding: 2px 6px; font-size: 10px; background: #555; margin-left: 5px; color: #ccc;}
        button.icon-btn:hover { background: #666; }

        /* --- Diff Colors --- */
        .ln-add { background-color: var(--diff-add-bg); width: 100%; display: inline-block; }
        .ln-del { background-color: var(--diff-del-bg); width: 100%; display: inline-block; opacity: 0.8; }
        /* When we display result, deleted lines might be hidden or crossed out depending on mode. 
           In 'Result' view, we typically don't show deleted lines. 
           But if showing a 'Diff', we do. */
        
        .ln-hdr { 
            color: var(--diff-hdr-text); 
            font-weight: bold; 
            display: block; 
            margin-top: 5px; margin-bottom: 5px;
            background: #2d2d2d;
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* --- Mobile --- */
        @media (max-width: 900px) {
            body { overflow: auto; height: auto; }
            .main-grid { flex-direction: column; height: auto; }
            .pane { height: 500px; border-right: none; border-bottom: 5px solid var(--border); }
            header { position: sticky; top: 0; z-index: 10; }
        }
    </style>
</head>
<body>

<header>
    <div class="control-group">
        <label title="Wrap long lines to fit visible area">
            <input type="checkbox" id="chkWrap" onchange="toggleWrap()"> <b>Word Wrap</b>
        </label>
    </div>

    <div class="control-group">
        <label title="Search Strictness (0% = Exact match only, 40% = Very loose)">
            Fuzzy: <input type="range" id="rngFuzzy" min="0" max="40" value="10" style="width:80px">
            <span id="valFuzzy" style="width:35px; text-align:right; font-family:monospace; font-weight:bold;">10%</span>
        </label>
        <label title="How far up/down to search for context (Search Radius)">
            Radius: <input type="number" id="numRadius" value="100" min="0" step="10">
        </label>
    </div>

    <div class="control-group" style="border:none">
        <label title="Lines of context around changes for Make Diff">
            Context: <input type="number" id="numContext" value="3" min="0">
        </label>
    </div>
</header>

<div class="main-grid">
    <!-- LEFT: ORIGINAL CODE -->
    <div class="pane">
        <div class="pane-title">
            <span>1. Original Source</span>
            <button class="icon-btn" onclick="clearPane('left')" title="Clear">x</button>
        </div>
        <div class="editor-wrapper" id="wrap-left">
            <div class="gutter" id="gutter-left"></div>
            <textarea id="input-left" class="editor-content" placeholder="// Paste original code here..." spellcheck="false"></textarea>
            <div class="mirror" id="mirror-left"></div>
        </div>
    </div>

    <!-- CENTER: DIFF INPUT / MODIFIED CODE -->
    <div class="pane">
        <div class="pane-title">
            <span>2. Diff / Modified Source</span>
            <button class="icon-btn" onclick="clearPane('center')" title="Clear">x</button>
        </div>
        <div class="editor-wrapper" id="wrap-center">
            <div class="gutter" id="gutter-center"></div>
            <textarea id="input-center" class="editor-content" placeholder="// Paste an AI DIFF here to Apply&#10;// OR paste full modified code to Make Diff" spellcheck="false"></textarea>
            <div class="mirror" id="mirror-center"></div>
        </div>
        <div class="controls">
            <button onclick="applyDiffAction()" title="Apply Center (Diff) to Left (Original) -> Result">Apply Diff &rarr;</button>
            <button class="secondary" onclick="makeDiffAction()" title="Compare Left vs Center -> Result">Make Diff</button>
        </div>
    </div>

    <!-- RIGHT: OUTPUT -->
    <div class="pane">
        <div class="pane-title">3. Result / Output</div>
        <div class="editor-wrapper" id="wrap-right">
            <div class="gutter" id="gutter-right"></div>
            <!-- Using contenteditable=false div for rich output -->
            <div id="output-right" class="editor-content view-mode"></div> 
        </div>
        <div class="controls" style="justify-content: flex-end;">
            <button class="secondary" onclick="copyResult()">Copy Result</button>
        </div>
    </div>
</div>

<script>
    const $ = id => document.getElementById(id);
    
    // ==========================================
    // 1. UI CORE: Sync Scrolling & Line Numbers
    // ==========================================
    const editors = {};

    function setupEditor(prefix, isTextarea = true) {
        const elInput = $(`input-${prefix}`) || $(`output-${prefix}`);
        const elGutter = $(`gutter-${prefix}`);
        const elWrapper = $(`wrap-${prefix}`);
        const elMirror = isTextarea ? $(`mirror-${prefix}`) : null; 

        editors[prefix] = { elInput, elGutter, elWrapper, elMirror, isTextarea };

        const updateLayout = () => {
            const isWrap = $('chkWrap').checked;
            elWrapper.classList.toggle('wrap-on', isWrap);

            let lines = [];
            
            if (isTextarea) {
                // For Textarea, we simulate wrapping using the mirror
                lines = elInput.value.split('\n');
                
                if (isWrap) {
                    // Sync mirror content
                    elMirror.innerHTML = '';
                    elMirror.style.width = elInput.clientWidth + 'px'; // Exact width match is crucial
                    
                    lines.forEach(line => {
                        const div = document.createElement('div');
                        // Use textContent to prevent HTML injection, but ensure space preserves height
                        div.textContent = line.length > 0 ? line : '\u200B'; // Zero-width space for empty line height
                        elMirror.appendChild(div);
                    });

                    // Measure heights
                    let html = '';
                    Array.from(elMirror.children).forEach((div, i) => {
                        html += `<div style="height:${div.offsetHeight}px">${i + 1}</div>`;
                    });
                    elGutter.innerHTML = html;
                } else {
                    // Fast path for no-wrap
                    const h = 20; // var(--line-height)
                    elGutter.innerHTML = lines.map((_, i) => `<div style="height:${h}px">${i+1}</div>`).join('');
                }
            } else {
                // For Output Div (HTML content)
                // We assume the output is generated as a list of <div> lines
                const children = Array.from(elInput.children);
                if (children.length === 0) {
                    elGutter.innerHTML = '';
                    return;
                }
                
                let html = '';
                children.forEach((child, i) => {
                    const h = child.offsetHeight;
                    // If header, don't show number, or show space
                    const num = child.getAttribute('data-ln') || (child.classList.contains('ln-hdr') ? ' ' : (i+1));
                    html += `<div style="height:${h}px">${num}</div>`;
                });
                elGutter.innerHTML = html;
            }
        };

        if (isTextarea) {
            elInput.addEventListener('input', updateLayout);
            elInput.addEventListener('scroll', () => elGutter.scrollTop = elInput.scrollTop);
            // Resize observer to handle window resize causing wrap changes
            new ResizeObserver(updateLayout).observe(elInput);
        } else {
             // For output div, scroll sync
             elInput.addEventListener('scroll', () => elGutter.scrollTop = elInput.scrollTop);
             new ResizeObserver(updateLayout).observe(elInput);
        }

        editors[prefix].update = updateLayout;
        updateLayout();
    }

    setupEditor('left', true);
    setupEditor('center', true);
    setupEditor('right', false);

    function toggleWrap() {
        Object.values(editors).forEach(ed => ed.update());
    }

    function clearPane(pane) {
        $(`input-${pane}`).value = '';
        editors[pane].update();
    }

    $('rngFuzzy').oninput = function() { $('valFuzzy').textContent = this.value + '%'; };

    // ==========================================
    // 2. CORE LOGIC: Apply Diff (Fuzzy)
    // ==========================================
    function applyDiffAction() {
        const srcText = $('input-left').value;
        const patchText = $('input-center').value;
        const fuzzyThreshold = parseInt($('rngFuzzy').value) / 100;
        const radius = parseInt($('numRadius').value) || 100;

        // Initialize as objects to handle mixed content safely later
        const srcLines = srcText.split('\n').map(l => ({ text: l, type: 'ctx' }));
        
        try {
            // 1. Parse Hunks
            const hunks = parseDiff(patchText);
            if (hunks.length === 0) throw new Error("No valid diff hunks (starting with @@) found in Center pane.");

            // 2. Apply Hunks
            const resultLines = fuzzyPatch(srcLines, hunks, fuzzyThreshold, radius);

            // 3. Render
            renderOutput(resultLines, false); // false = show as file (not diff view)

        } catch (e) {
            alert("Error applying diff:\n" + e.message);
            console.error(e);
        }
    }

    function parseDiff(text) {
        const lines = text.split('\n');
        const hunks = [];
        let currentHunk = null;

        for (let line of lines) {
            if (line.startsWith('@@')) {
                // Parse Header: @@ -OldStart,OldLen +NewStart,NewLen @@
                const m = line.match(/@@\s*-(\d+)(?:,(\d+))?\s+\+(\d+)(?:,(\d+))?\s*@@/);
                if (m) {
                    if (currentHunk) hunks.push(currentHunk);
                    currentHunk = {
                        oldStart: parseInt(m[1]),
                        lines: []
                    };
                }
            } else if (currentHunk) {
                // Collect lines
                if (line.startsWith('+')) currentHunk.lines.push({ op: '+', content: line.slice(1) });
                else if (line.startsWith('-')) currentHunk.lines.push({ op: '-', content: line.slice(1) });
                else if (line.startsWith(' ')) currentHunk.lines.push({ op: ' ', content: line.slice(1) });
                else if (line === '') currentHunk.lines.push({ op: ' ', content: '' }); // Empty context line often loses space
                // Ignore other lines
            }
        }
        if (currentHunk) hunks.push(currentHunk);
        return hunks;
    }

    function fuzzyPatch(fileLines, hunks, threshold, radius) {
        let result = [...fileLines];
        let offset = 0; // Shift in line numbers due to previous insertions/deletions

        hunks.forEach((hunk, hIdx) => {
            // 1. Identify the "Anchor Block" in the hunk (Context + Deletions)
            const anchorBlock = hunk.lines.filter(l => l.op === ' ' || l.op === '-');
            
            // Expected location in the *current* result array (adjusted by offset)
            let expectedIndex = (hunk.oldStart - 1) + offset;
            
            // 2. Find Best Match
            let bestIdx = -1;
            let bestScore = -1.0;

            // Search range: [expected - radius, expected + radius]
            for (let r = 0; r <= radius; r++) {
                const offsets = r === 0 ? [0] : [r, -r];
                
                for (let dir of offsets) {
                    let idx = expectedIndex + dir;
                    
                    if (idx < 0 || idx >= result.length) continue;
                    // If block exceeds file end significantly (allow 1 line slack for EOF)
                    if (idx + anchorBlock.length > result.length + 1) continue; 

                    // Calculate Score
                    let scoreSum = 0;
                    let validLines = 0;

                    for (let k = 0; k < anchorBlock.length; k++) {
                        if (idx + k >= result.length) break; 
                        
                        const srcLineObj = result[idx + k];
                        
                        // Robust trim: check if it is string or object (should be object due to init, but safety first)
                        const srcTxt = (typeof srcLineObj === 'string' ? srcLineObj : srcLineObj.text);
                        const patTxt = anchorBlock[k].content;
                        
                        const sT = srcTxt.trim();
                        const pT = patTxt.trim();
                        
                        let sim = 0;
                        if (sT === pT) {
                            sim = 1;
                        } else {
                            const maxLen = Math.max(sT.length, pT.length);
                            if (maxLen === 0) sim = 1;
                            else {
                                const dist = levenshtein(sT, pT);
                                sim = 1 - (dist / maxLen);
                            }
                        }
                        
                        scoreSum += sim;
                        validLines++;
                    }

                    if (validLines === 0 && anchorBlock.length === 0) {
                         // Insert only hunk (no context/deletions)? Match is perfect at index.
                         bestScore = 1; bestIdx = idx; break;
                    }

                    const avgScore = validLines > 0 ? (scoreSum / validLines) : 0;

                    if (avgScore > bestScore) {
                        bestScore = avgScore;
                        bestIdx = idx;
                    }
                }
                if (bestScore === 1.0) break; // Found exact match
            }

            // Check Threshold
            if (bestScore < (1.0 - threshold)) {
                // Insert warning in file
                const warnMsg = `<<<< ERR: Hunk #${hIdx+1} failed to match (Score ${bestScore.toFixed(2)}) >>>>`;
                result.splice(Math.max(0, expectedIndex), 0, { text: warnMsg, type: 'del' });
                offset += 1;
                return; // Skip this hunk
            }

            // 3. Construct Replacement Block
            const newSegment = [];
            let consumedCount = 0;

            hunk.lines.forEach(hLine => {
                if (hLine.op === ' ') {
                    // Context: Keep the original line from source to minimize noise
                    if (bestIdx + consumedCount < result.length) {
                        const original = result[bestIdx + consumedCount];
                        newSegment.push({ text: original.text, type: 'ctx' }); 
                        consumedCount++;
                    } else {
                         // End of file edge case
                         newSegment.push({ text: hLine.content, type: 'ctx' });
                    }
                } else if (hLine.op === '-') {
                    // Delete: Consume source line, don't output
                    consumedCount++;
                } else if (hLine.op === '+') {
                    // Add: Output new line
                    newSegment.push({ text: hLine.content, type: 'add' });
                }
            });

            // 4. Splice into Result
            result.splice(bestIdx, consumedCount, ...newSegment);

            // 5. Update Offset
            offset += (newSegment.length - consumedCount);
        });

        return result;
    }

    // ==========================================
    // 3. CORE LOGIC: Make Diff
    // ==========================================
    function makeDiffAction() {
        const leftText = $('input-left').value.split('\n');
        const rightText = $('input-center').value.split('\n');
        const contextLines = parseInt($('numContext').value) || 3;

        // Compute LCS
        const matrix = lcsMatrix(leftText, rightText);
        const diffOps = backtrackLCS(matrix, leftText, rightText);

        // Group into Hunks
        const hunks = groupHunks(diffOps, contextLines);

        // Render Diff View
        renderDiffView(hunks);
    }

    function lcsMatrix(t1, t2) {
        const N = t1.length;
        const M = t2.length;
        // Flat array for performance optimization if needed, but 2D array is easier to read
        const dp = Array(N + 1).fill(null).map(() => new Uint16Array(M + 1));
        
        for (let i = 1; i <= N; i++) {
            for (let j = 1; j <= M; j++) {
                if (t1[i - 1] === t2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp;
    }

    function backtrackLCS(dp, t1, t2) {
        let i = t1.length, j = t2.length;
        const result = [];
        while (i > 0 || j > 0) {
            if (i > 0 && j > 0 && t1[i - 1] === t2[j - 1]) {
                result.push({ op: ' ', text: t1[i - 1] });
                i--; j--;
            } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
                result.push({ op: '+', text: t2[j - 1] });
                j--;
            } else {
                result.push({ op: '-', text: t1[i - 1] });
                i--;
            }
        }
        return result.reverse();
    }

    function groupHunks(ops, ctxSize) {
        const hunks = [];
        let i = 0;
        let oldLine = 1, newLine = 1;

        while (i < ops.length) {
            // Find next change
            if (ops[i].op === ' ') {
                oldLine++; newLine++;
                i++;
                continue;
            }

            // Change found. Start Hunk.
            const startIdx = Math.max(0, i - ctxSize);
            
            // Re-calculate line numbers for start of hunk
            let hOld = oldLine;
            let hNew = newLine;
            for(let k=i-1; k>=startIdx; k--) {
                if(ops[k].op !== '+') hOld--;
                if(ops[k].op !== '-') hNew--;
            }

            // Find end of hunk (change + context)
            let endIdx = i;
            while(endIdx < ops.length) {
                if (ops[endIdx].op !== ' ') {
                    endIdx++; // consume change
                    continue;
                }
                // Check if we have enough clear context ahead to close hunk
                let clearContext = 0;
                let lookAhead = endIdx;
                while(lookAhead < ops.length && ops[lookAhead].op === ' ' && clearContext < ctxSize) {
                    clearContext++;
                    lookAhead++;
                }
                if (lookAhead < ops.length && ops[lookAhead].op !== ' ' && clearContext < ctxSize) {
                    endIdx = lookAhead; // Jump to next change
                } else {
                    endIdx += clearContext;
                    break;
                }
            }

            // Create Hunk
            const slice = ops.slice(startIdx, endIdx);
            let oldCnt = 0, newCnt = 0;
            slice.forEach(op => {
                if (op.op !== '+') oldCnt++;
                if (op.op !== '-') newCnt++;
            });

            hunks.push({
                header: `@@ -${hOld},${oldCnt} +${hNew},${newCnt} @@`,
                lines: slice
            });

            // Advance cursor to end of this hunk
            for(let k=i; k<endIdx; k++) {
                if(ops[k].op !== '+') oldLine++;
                if(ops[k].op !== '-') newLine++;
            }
            
            i = endIdx;
        }
        return hunks;
    }

    // ==========================================
    // 4. RENDERING & HELPERS
    // ==========================================
    function renderOutput(lines, isDiffView) {
        const container = $('output-right');
        let html = '';
        let copyText = '';

        lines.forEach((line, idx) => {
            const safeText = escapeHtml(line.text || '');
            let cls = '';
            
            if (line.type === 'add') cls = 'ln-add';
            else if (line.type === 'del') cls = 'ln-del'; 
            else if (line.type === 'hdr') cls = 'ln-hdr';
            
            const lnAttr = line.type === 'hdr' ? '' : `data-ln="${idx+1}"`; 
            
            html += `<div class="${cls}" ${lnAttr}>${safeText.length === 0 ? ' ' : safeText}</div>`;
            copyText += line.text + '\n';
        });

        container.innerHTML = html;
        container._copyText = copyText; 
        editors.right.update();
    }

    function renderDiffView(hunks) {
        const container = $('output-right');
        let html = '';
        let copyText = '';
        
        // Header
        const header = "--- a/original\n+++ b/modified\n";
        html += `<div class="ln-hdr">${escapeHtml(header)}</div>`;
        copyText += header;

        if(hunks.length === 0) {
            html += "<div>No changes</div>";
        }

        hunks.forEach(h => {
            html += `<div class="ln-hdr">${escapeHtml(h.header)}</div>`;
            copyText += h.header + '\n';
            
            h.lines.forEach(l => {
                let cls = '';
                if(l.op === '+') cls = 'ln-add';
                if(l.op === '-') cls = 'ln-del';
                
                const txt = l.op + l.text;
                html += `<div class="${cls}">${escapeHtml(txt)}</div>`;
                copyText += txt + '\n';
            });
        });

        container.innerHTML = html;
        container._copyText = copyText;
        editors.right.update();
    }

    function levenshtein(a, b) {
        if (!a) return b ? b.length : 0;
        if (!b) return a.length;
        const m = a.length, n = b.length;
        let row = new Int32Array(n + 1);
        for (let j = 0; j <= n; j++) row[j] = j;
        
        for (let i = 1; i <= m; i++) {
            let prev = i;
            for (let j = 1; j <= n; j++) {
                let val;
                if (a[i - 1] === b[j - 1]) val = row[j - 1]; 
                else val = Math.min(row[j - 1], row[j], prev) + 1;
                row[j - 1] = prev;
                prev = val;
            }
            row[n] = prev;
        }
        return row[n];
    }

    function escapeHtml(text) {
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    function copyResult() {
        const text = $('output-right')._copyText || $('output-right').innerText;
        navigator.clipboard.writeText(text).then(() => {
            const btn = document.querySelector('button[onclick="copyResult()"]');
            const old = btn.textContent;
            btn.textContent = "Copied!";
            setTimeout(() => btn.textContent = old, 1500);
        });
    }
</script>
</body>
</html>
